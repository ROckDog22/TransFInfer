/**
 * 通常在每个.hpp文件的开头添加一个宏定义是为了防止重复包含include同一个文件，以避免编译错误，这个宏定义通常称为头文件保护或预编译
 * 指令，它的作用是确保每个头文件在编译过程中只被包含一次，当一个头文件被包含多次时，编译器会将其内容重复插入到包含它的源文件中，这
 * 可能导致一些问题，例如重复定义的函数，变量，结构体等，头文件保护宏定义可以在第一次包含时生效，后续的包含会被宏定义排除掉，从而确保
 * 头文件只被包含一次
 * 一般采用头文件的名称全大写的形式，当为真时，进入#define部分，将变量定义为非零值，然后编译头文件的内容，当再次包含同一个头文件时，
 * 条件为假，因此跳过头文件的内容，避免了重复定义的问题
*/
#ifndef TRANSFINFER_INCLUDE_DATA_LOAD_DATA_H
#define TRANSFINFER_INCLUDE_DATA_LOAD_DATA_H
#include <armadillo>
#include <string>
namespace TransFInfer {

class CSVDataLoader {
    public:
/** static 关键字可以用于声明静态成员变量和静态成员函数 
 * 静态成员变量 是类的成员，但它们与类的实例无关，而是与类本身相关联，它们只有一个副本，被所有类的实例共享，静态成员变量在类的所有实例
 * 之间保持相同的值，并且可以通过类名或对象访问，静态成员变量在程序运行期间一直存在，知道程序结束。在类声明中，可以使用static关键字
 * 来声明静态成员变量，并在类的外部初始化它，静态成员变量的定义通常在类的实现文件中进行，而不是在头文件中
 * 通过类名访问，通过对象访问
 * 静态成员函数，
 * 静态成员函数时不依赖于类的实例而存在的函数，它们只能访问类的静态成员（静态成员变量和其他静态成员函数），而不能访问非静态成员，静态成员
 * 函数与类本省关联，而不是与类的实例关联，因此可以通过类名直接调用静态成员函数，而无需创建类的实例，静态成员函数在类的声明中使用static关键字
 * 进行声明，并在类外部进行定义和实现
 * 静态成员变量和静态成员函数与类的实例无关，它们可以直接通过类名进行访问，同时，静态成员函数无法访问非静态成员变量或成员函数，因为
 * 它们没有隐式的this指针，静态成员函数在一些特定情况下非常有用，例如实现与类相关的全局功能和计数器等。
 * public 静态成员方法，可以被类的实例和类本身直接访问，也就是说，它对外是可见的，private 只能在类的内部访问，外部无法直接调用，
 * 只有类的其他成员函数可以访问和调用其private静态成员方法
 */
   static arma::fmat LoadData(const std::string &file_path, char split_char=',');
  private:
    static std::pair<size_t, size_t> GetMatrixSize(std::ifstream &file, char split_char);
};
}

#endif //TRANSFINFER_INCLUDE_DATA_LOAD_DATA_HPP_